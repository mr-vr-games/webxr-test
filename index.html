<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Grassland Experience</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #enterVR {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: Arial, sans-serif;
            font-size: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="loading">Loading luxurious environment...</div>
    <button id="enterVR" style="display: none;">Enter VR</button>
    
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.module.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/loaders/GLTFLoader.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/webxr/XRControllerModelFactory.js';
        import { Sky } from 'https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/objects/Sky.js';
        import { Water } from 'https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/objects/Water.js';
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.FogExp2(0xd7e1e9, 0.0005);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
        camera.position.set(0, 1.6, 0);
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        // XR setup
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local-floor');
        
        // Custom VR button
        const enterVRButton = document.getElementById('enterVR');
        enterVRButton.addEventListener('click', () => {
            renderer.xr.startSession('immersive-vr', {
                requiredFeatures: ['local-floor']
            });
        });
        
        // Check for XR capability
        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                if (supported) {
                    enterVRButton.style.display = 'block';
                } else {
                    console.log('WebXR immersive-vr not supported');
                }
            });
        }
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(500, 1500, 1000);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 100;
        directionalLight.shadow.camera.far = 3000;
        directionalLight.shadow.camera.left = -1000;
        directionalLight.shadow.camera.right = 1000;
        directionalLight.shadow.camera.top = 1000;
        directionalLight.shadow.camera.bottom = -1000;
        scene.add(directionalLight);
        
        // Sky
        const sky = new Sky();
        sky.scale.setScalar(10000);
        scene.add(sky);
        
        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 10;
        skyUniforms['rayleigh'].value = 2;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.8;
        
        const sun = new THREE.Vector3();
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        
        function updateSun() {
            const phi = THREE.MathUtils.degToRad(88);
            const theta = THREE.MathUtils.degToRad(180);
            
            sun.setFromSphericalCoords(1, phi, theta);
            
            sky.material.uniforms['sunPosition'].value.copy(sun);
            
            if (water) {
                water.material.uniforms['sunDirection'].value.copy(sun).normalize();
            }
            
            scene.environment = pmremGenerator.fromScene(sky).texture;
        }
        
        updateSun();
        
        // Water
        let water;
        const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
        water = new Water(
            waterGeometry,
            {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', function (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                }),
                sunDirection: new THREE.Vector3(),
                sunColor: 0xffffff,
                waterColor: 0x001e0f,
                distortionScale: 3.7,
                fog: scene.fog !== undefined
            }
        );
        water.rotation.x = -Math.PI / 2;
        water.position.y = -0.5;
        scene.add(water);
        
        // Ground - Grass plane
        const groundTextureLoader = new THREE.TextureLoader();
        
        const grassTexture = groundTextureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(25, 25);
        grassTexture.anisotropy = 16;
        
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            map: grassTexture,
            roughness: 0.8,
            metalness: 0.2
        });
        
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(10000, 10000),
            groundMaterial
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Trees
        const treePositions = [];
        for (let i = 0; i < 200; i++) {
            const x = Math.random() * 1000 - 500;
            const z = Math.random() * 1000 - 500;
            
            // Don't place trees too close to the starting position
            if (Math.sqrt(x * x + z * z) > 15) {
                treePositions.push({ x, z });
            }
        }
        
        // Create a simple tree geometry
        function createSimpleTree() {
            const group = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            group.add(trunk);
            
            // Leaves
            const leavesGeometry = new THREE.ConeGeometry(3, 6, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 6;
            leaves.castShadow = true;
            group.add(leaves);
            
            return group;
        }
        
        // Add trees to the scene
        treePositions.forEach(pos => {
            const tree = createSimpleTree();
            tree.position.set(pos.x, 0, pos.z);
            tree.scale.set(
                0.5 + Math.random() * 1.5,
                0.5 + Math.random() * 2,
                0.5 + Math.random() * 1.5
            );
            tree.rotation.y = Math.random() * Math.PI * 2;
            scene.add(tree);
        });
        
        // Detailed grass patches
        const detailedGrassGeometry = new THREE.PlaneGeometry(1, 1);
        const detailedGrassTexture = groundTextureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-small.jpg');
        detailedGrassTexture.wrapS = detailedGrassTexture.wrapT = THREE.RepeatWrapping;
        detailedGrassTexture.repeat.set(1, 1);
        
        const detailedGrassMaterial = new THREE.MeshStandardMaterial({
            map: detailedGrassTexture,
            alphaTest: 0.5,
            side: THREE.DoubleSide,
            roughness: 1.0,
            metalness: 0.0
        });
        
        // Create grass patches
        for (let i = 0; i < 5000; i++) {
            const grass = new THREE.Mesh(detailedGrassGeometry, detailedGrassMaterial);
            const x = Math.random() * 1000 - 500;
            const z = Math.random() * 1000 - 500;
            grass.position.set(x, 0.2 + Math.random() * 0.3, z);
            grass.rotation.x = -Math.PI / 2;
            grass.rotation.z = Math.random() * Math.PI;
            grass.scale.setScalar(0.5 + Math.random());
            scene.add(grass);
        }
        
        // Add controller setup
        const controllerModelFactory = new XRControllerModelFactory();
        
        const controllers = [];
        const controllerGrips = [];
        
        // Controller 0
        const controller0 = renderer.xr.getController(0);
        scene.add(controller0);
        controllers.push(controller0);
        
        const controllerGrip0 = renderer.xr.getControllerGrip(0);
        controllerGrip0.add(controllerModelFactory.createControllerModel(controllerGrip0));
        scene.add(controllerGrip0);
        controllerGrips.push(controllerGrip0);
        
        // Controller 1
        const controller1 = renderer.xr.getController(1);
        scene.add(controller1);
        controllers.push(controller1);
        
        const controllerGrip1 = renderer.xr.getControllerGrip(1);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);
        controllerGrips.push(controllerGrip1);
        
        // Movement variables
        const playerVelocity = new THREE.Vector3();
        const tempVector = new THREE.Vector3();
        const gamepadData = [null, null];
        
        // Handle controller input
        function handleController(controller, index, delta) {
            if (!controller.gamepad) return;
            
            gamepadData[index] = controller.gamepad;
            
            // Read gamepad axes
            const axes = controller.gamepad.axes;
            if (axes.length >= 2) {
                // Y-axis (index 1) controls forward/backward
                // X-axis (index 0) controls left/right
                
                // Get forward direction relative to camera
                tempVector.set(0, 0, -1).applyQuaternion(camera.quaternion);
                tempVector.y = 0; // Keep movement horizontal
                tempVector.normalize();
                
                // Apply forward/backward movement
                playerVelocity.copy(tempVector).multiplyScalar(-axes[1] * 5 * delta);
                
                // Get right direction
                tempVector.set(1, 0, 0).applyQuaternion(camera.quaternion);
                tempVector.y = 0;
                tempVector.normalize();
                
                // Apply left/right movement
                playerVelocity.add(tempVector.multiplyScalar(axes[0] * 5 * delta));
                
                // Move the camera (and by extension, the player)
                camera.position.add(playerVelocity);
            }
        }
        
        // Handle XR connected
        function onConnected(event) {
            const xrSession = renderer.xr.getSession();
            if (xrSession.inputSources && xrSession.inputSources.length) {
                for (let i = 0; i < xrSession.inputSources.length; i++) {
                    const inputSource = xrSession.inputSources[i];
                    if (inputSource.gamepad) {
                        controllers[i].gamepad = inputSource.gamepad;
                    }
                }
            }
        }
        
        // Register WebXR session event
        renderer.xr.addEventListener('sessionstart', () => {
            const session = renderer.xr.getSession();
            session.addEventListener('inputsourceschange', onConnected);
        });
        
        // Animation loop
        const clock = new THREE.Clock();
        
        function animate() {
            const delta = clock.getDelta();
            
            // Update water
            if (water) {
                water.material.uniforms['time'].value += delta;
            }
            
            // Handle controller input for movement
            controllers.forEach((controller, index) => {
                handleController(controller, index, delta);
            });
            
            renderer.render(scene, camera);
        }
        
        renderer.setAnimationLoop(animate);
        
        // Resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Hide loading message when everything is ready
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
        }, 3000);
        import './game.js';
    </script>
</body>
</html>

